---
layout: post
title:  "분노의 기술 면접 준비"
categories: tech-interview
---

* toc
{:toc}

## 운영체제

### 프로세스

#### 프로세스와 스레드의 차이는 무엇인가요?

<details>
<summary markdown="span">정의</summary>

프로그램: 어떤 작업을 위해 실행할 수 있는 파일

프로세스: 실행되고 있는 프로그램의 인스턴스. 하나 또는 여러개의 쓰레드와 관련된 시스템 자원(코드나 데이터/열린 파일 등을 가진 메모리 공간)의 집합.

쓰레드: dispatch 가능한 작업의 단위, 프로세서 컨텍스트(PC, Stack Pointer 등)와 데이터 영역인 stack을 가지고 있음. 쓰레드는 순차적으로 실행되고, 인터럽트 가능해서 다른 스레드로 전환될 수 있음.

</details>

<details>
<summary markdown="span">차이점</summary>

1. 프로세스는 보통 독립적이지만 쓰레드는 프로세스에 속해있음.
2. 프로세스는 쓰레드보다 더 많은 상태 정보를 가지고 있음. 쓰레드는 이 자원들은 프로세스로부터 공유받음.
3. 컨텍스트 스위칭은 프로세스 사이보다 쓰레드 사이가 더 빠름.
4. 멀티 쓰레드가 멀티 프로세스보다 자원 소비가 적음.
5. 프로세스는 분리된 주소 공간을 가짐. 쓰레드는 자기들의 주소 공간을 공유함. 그래서 한 쓰레드의 오류가 다른 쓰레드에 영향을 줄 수 있음.
6. 프로세스 간 상호작용은 IPC나 메세지 패싱 등을 사용해야 해서 복잡함. 쓰레드는 서로 이미 공유하는 파일이나 데이터로 할 수 있어서 간단함.

</details>

#### 교착상태란 무엇이며, 교착상태가 발생하기 위해서는 어떤 조건이 있어야 하나요?

<details>
<summary markdown="span">정의</summary>

한 그룹의 각 멤버가 행동하기 위해 자신을 포함한 다른 멤버를 기다리고 있는 상태

</details>

<details>
<summary markdown="span">조건</summary>

교착상태는 아래의 조건을 모두 만족하는 것과 동일함.

1. Mutual exclusion: 한 시점에 한 프로세스만 사용 가능한 자원
2. Hold and wait: 프로세스가 한 자원을 소유하는 중에 다른 프로세스가 들고 있는 자원을 요청함.
3. No preemption: 자원은 소유하고 있는 프로세스만 반환할 수 있음.
4. Circular wait: 각 프로세스는 반드시 다른 프로세스의 자원을 기다리고 있음.

</details>

<details>
<summary markdown="span">기타 지식</summary>

Starvation: 특정 프로세스가 자신에게 필요한 자원을 영구적으로 거부당하고 있는 상태
LiveLock: 프로세스의 상태는 바뀌지만 진행되지 않는 상태

</details>

#### 교착상태의 해결법은 무엇인가요?

<details>
<summary markdown="span">해결법</summary>

1. 무시: 교착상태가 일어나지 않을 거라 간주하고 감지나 예방 방법을 적용하지 않음.
2. 감지: 교착상태가 발생했는지 감지함. 감지되면 관련된 프로세스를 전부 종료하거나 체크포인트로 되돌리기, 순차적으로 자원을 선점시키기 등으로 회복함.
3. 예방: 교착상태가 일어나지 않도록 4원칙 중 하나라도 만족할 수 없는 시스템 설계, 비효율적
4. 회피: 동적으로 교착상태가 발생할 수 있는 자원 접근을 차단함. 은행원 알고리즘.

</details>

#### 은행원 알고리즘

작성 필요

#### 뮤텍스와 세마포어에 대해서 설명해 보시오

<details>
<summary markdown="span">설명</summary>

* 뮤텍스: 자원을 사용할 때 특정 변수의 소유권을 가져오고, 끝나면 소유권을 반환하는 방식의 상호배제 기법  
* 세마포어: 동시에 자원을 사용할 수 있는 수를 나타내는 값을 두고 증감시키는 방식의 상호배제 기법

</details>

#### 컨텍스트 스위칭이란 무엇인가요?

<details>
<summary markdown="span">정의</summary>

나중에 복원되거나 실행을 재개하기 위해 프로세스나 쓰레드의 상태를 저장하는 과정  
멀티태스킹, 인터럽트 핸들링, 유저/커널 모드 스위칭의 경우가 있음.

</details>

<details>
<summary markdown="span">순서</summary>

1. 프로세스가 사용한 레지스터 값이 포함된 프로세스의 상태를 PCB에 저장함.
2. PCB 대한 핸들을 프로세스 실행 대기열인 ready queue에 추가함.
3. OS가 현재 프로세스를 끝내면 ready queue에서 다음 프로세스를 선택하고 PCB를 복구함. 프로그램 카운터가 PCB를 통해 불러와지고, 다음 프로세스가 재개됨.

</details>

#### PC와 PID

<details>
<summary markdown="span">설명</summary>

* PC: 프로그램 카운터, 다음에 실행될 명령어의 주소가 들어있는 레지스터  
* PCB: 프로세스 제어 블록, 프로세스의 중요 정보 저장/context switching에 사용, PID/상태/PC값 등을 담고 있음.

</details>

#### 경쟁 상태란 무엇인가요?

<details>
<summary markdown="span">설명</summary>

여러 개의 프로세스나 쓰레드가 데이터를 읽고 쓰는 과정에서 최종 결과가 명령어의 실행된 순서에 의해 결정되는 것.

</details>

#### 프로세스 혹은 스레드의 동기화란 무엇인가요?

<details>
<summary markdown="span">설명</summary>

* 동기화: 동시에 두 개 이상의 쓰레드나 프로세스가 크리티컬 세션을 동시에 실행하지 않도록 하는 방법들  
* 크리티컬 세션: 공유 자원에 대한 동시 접근을 막아야 되는 프로그램 영역.

</details>

#### 사용자 수준의 스레드와 커널 수준의 스레드의 차이는 무엇인가요?

작성 필요

#### CPU 스케줄링이란 무엇인가요?

<details>
<summary markdown="span">정의</summary>

멀티태스킹 환경에서 효율적이고 빠르고 공평하게 시스템을 쓸 수 있도록 CPU에 작업을 할당하는 과정

</details>

#### CPU 스케줄링 방법에는 대표적으로 어떤 것들이 있나요?

<details>
<summary markdown="span">방법들</summary>

* First Come First Serve: convoy effect 발생(앞에 긴 작업 때문에 뒤의 짧은 작업들이 밀려서 OS 전체가 느려짐.)
* Priority Scheduling: FCFS에 우선순위를 둠. 예시로 Realtime OS에서 시간제한을 기준으로 함.
* Shortest Job First: 실행시간이 짧은 작업 우선(비선점)
* Highest Response Ratio Next: 대기시간/예상작업시간 으로 우선순위를 정함.(비선점)
* Shortest Remaining Time First: 예상 완료시간이 가장 짧은 프로세스를 선택함. 만약 새로 들어온 작업이 실행 중인 작업보다 빨리 끝난다면 교체함.(선점)
* Longest Remaining Time First: SRTF의 반대
* Round Robin: 단위 시간으로 쪼개서 정해진 시간이 지나면 다음 프로세스가 선점하게 함.
* Multilevel Queue Scheduling: 프로세스를 쉽게 나눠지는 기준으로 나누고 각각에 다른 스케쥴링을 적용함. ex) foreground/background
* Multilevel Feedback Queue Scheduling: 프로세스가 그룹 사이를 옮길 수 있어야 할 때 사용함. ex) low/high priority queue를 만들어서 프로세스의 상태에 따라 옮김.

SJF 계열은 프로세스의 정확한 실행시간을 미리 알 수 있어야 된다는 점 때문에 실생활에선 보기 힘듦.

</details>

<details>
<summary markdown="span">기타 지식 - 스케쥴러의 종류</summary>

* 장기 스케쥴러: ready queue에 들어갈 프로세스를 결정함.
* 중기 스케쥴러: 페이지 교체를 결정함.
* 단기 스케쥴러: ready queue에서 CPU에 할당될 프로세스를 결정함. <- CPU scheduler

</details>

#### 동기와 비동기, 블로킹과 넌블로킹의 차이는 무엇인가요?

<details>
<summary markdown="span">차이점</summary>

비교대상에 따라 다름. 그리고 이 답변은 IO에서의 얘기임. thread 간에는 다름.

* 동기/비동기: 시스템 콜의 완료를 기다리는가, 즉시 리턴되는가
* 블로킹/넌블로킹: 대기큐에 들어가는가/시스템콜이 완료된 후에 오는가
* 비동기/넌블로킹: 시스템콜이 즉시 리턴될 때, 0이든 일부든 전부든 간에 데이터가 오면 넌블로킹/안오면 비동기
* 동기/블로킹: 시스템 콜이 끝날 때까지 대기 큐에 들어가지 않는가? (비동기 IO의 spinning이 동기와 유사함.)

||동기|블로킹|비동기|넌블로킹|
|-|-|-|-|-|
|시스템 콜 기다림|O|O|X|X|
|즉시 반환됨|X|X|O|O|
|데이터와 함께 반환됨|O|O|X|O|
|대기 큐에서 기다림|X|O|X|X|

</details>

### 메모리

#### C에서 메모리를 어떻게 할당하는가?

<details>
<summary markdown="span">할당 방법</summary>

* 정적 할당: 프로그램 시작 시 정해진 메모리를 할당함. 스택. 메모리 누수 없음. 할당된 크기는 조절 불가  
* 동적 할당: 런타임 중 할당함, 다른 스레드가 사용하지 못하게 예약해버림. 힙. 상황에 따라 자유롭게 할당하고 조절할 수 있음. 직접 해제해야 한다면 메모리 누수 문제, GC를 쓴다면 성능 저하가 있음.

</details>

#### 프로세스에 할당되는 메모리의 각 영역에 대해서 설명해 주세요

<details>
<summary markdown="span">프로세스 내 메모리 구조</summary>

1. 스택: 낮은 메모리 주소 방향으로 자라남, 지역변수/매개변수/반환값 등
2. 힙: 높은 메모리 주소 방향으로 자라남, 동적으로 메모리를 할당하는 곳, 프로세스 내의 모든 쓰레드, 동적 모듈, 공유 라이브러리들이 공유함.
3. BSS: 정적으로 정의되었지만 초기값이 없는 변수들.
4. 데이터: 정적으로 정의된 값들, 전역변수/정적변수/상수/구조체
5. 코드(텍스트): 명령어가 들어감, 고정된 크기

</details>

#### 메모리 구조의 순서가 어떻게 되는가? CPU에서 가까운 순으로 말해보시오

<details>
<summary markdown="span">메모리 계층</summary>

내려갈 수록 비트당 비용이 줄고, 접근 시간과 용량이 늘어남. 접근하는 빈도가 적음.

1. Inboard Memory: 레지스터, 캐시, 메인 메모리
2. Outboard Memory: 보조기억장치
3. Off-line Storage: 사람에 의해 연결/제거가 가능한 보조기억장치, Flash Drive, 광학 디스크

</details>

#### 페이지와 세그멘테이션에 대해서 설명해 보시오

<details>
<summary markdown="span">페이징</summary>

* 프레임: 주기억장치의 고정 길이 블록, 프레임 번호와 오프셋으로 구성됨.  
* 페이지: 보조기억장치에 저장된 데이터의 고정 길이 블록, 페이지 번호와 오프셋으로 구성됨.
* 페이지 테이블: 페이지 번호 순으로 해당되는 프레임 번호가 있음.
* 페이징: 페이지를 사용한 메모리 관리 방법. 프로세스에 페이지 테이블을 선언해서 프로세스의 프레임이 연속되지 않더라도 페이지 테이블과 논리 주소를 통해 빠르게 접근할 수 있게 함. 외부 단편화는 없지만 내부 단편화가 존재

</details>

<details>
<summary markdown="span">세그멘테이션</summary>

* 세그멘트: 보조기억장치에 저장된 가변 길이 블록, 세그멘트 번호와 오프셋으로 구성됨.
* 세그멘트 테이블: 세그멘트 번호 순으로 해당되는 세그멘트의 길이와 시작 주소가 있음.
* 세그멘테이션: 세그멘트를 사용한 메모리 관리 방법. 프로세스에 세그멘트 테이블을 선언해서 프로세스가 여러 파티션으로 나뉘더라도 빠르게 접근할 수 있게 함. 내부 단편화는 없지만 외부 단편화가 존재

</details>

#### 외부 단편화란? 내부 단편화란?

<details>
<summary markdown="span">정의</summary>

* 내부 단편화: 데이터가 할당된 파티션의 크기보다 불러온 데이터의 크기가 작아서 낭비된 공간이 존재함.  
* 외부 단편화: 메모리에서 파티션을 제외한 나머지 공간이 잘게 쪼개짐.

</details>

#### First Fit, Best Fit, Worst Fit에 대해서 설명해 보시오

<details>
<summary markdown="span">설명</summary>

OS가 프로세스를 메모리에 할당할 때 여유 공간들 중 선택하는 알고리즘

* First Fit: 메모리 시작부터 스캔해서 프로세스를 담을 수 있을 정도의 크기의 첫번째 블록에 할당
* Best Fit: 프로세스의 크기에 가장 가까운 크기의 블록에 할당
* Next Fit: 이전에 할당한 위치부터 프로세스를 담을 수 있는 다음 블록에 할당.

</details>

#### 페이지 교체 알고리즘 종류에는 어떤 것들이 있나요?

<details>
<summary markdown="span">정의와 종류</summary>

더 이상 주기억장치에 공간이 없을 때, 새 페이지와 자리를 교체할 기존 페이지를 결정하는 알고리즘

* Optimal: 가장 페이지 폴트가 적게 나도록 교체하는 방법. 미래 예측이 가능하지 않는 이상 구현 불가.  
* LRU: 가장 오래전에 참조된 페이지를 교체함. 참조 기록이 필요함.  
* FIFO: 가장 오래전에 메모리에 적재된 페이지를 교체함.  
* Clock: 모든 페이지를 원형 버퍼에 넣고 페이지가 들어오거나 참조되면 비트를 1로 바꿈. 페이지를 교체할 때가 되면, 버퍼를 스캔해서 비트가 0인 페이지를 교체함. 버퍼에 갱신이 일어나면 포인터를 다음으로 옮기고 가리킨 페이지의 비트를 0으로 바꿈.  

</details>

#### 캐시 메모리

작성 필요

## 네트워크

### 전산 기본

#### OSI 7계층에 대해서 설명해주세요

<details>
<summary markdown="span">설명</summary>

여러 네트워크 장비들의 상호호환성을 위해 네트워크 프로토콜을 특징에 따라 7계층으로 분류한 기준  
전기 신호에서 프로그램이 인식할 수 있는 데이터가 되기까지의 네트워크 흐름이 정의되어 있음. 데이터는 각 계층을 지날 때마다 캡슐화됨.  
계층으로 정의되었기 때문에 인접한 계층에만 의존한다는 점과 오류 파악이 용이하다는 장점이 있다.

1. 물리 계층: 전기 신호를 전달하고 읽는 역할. 유무선 통신 기술이 포함됨.
2. 데이터 링크 계층: 직접 연결된 노드 간 통신을 관리함. 물리 장치를 식별할 수 있는 주소 지정과 오류 감지, 흐름 제어를 함.
3. 네트워크 계층: 네트워크 간 통신을 관리함. 논리 주소인 IP를 확인하며 라우팅과 포워딩을 주로 수행함.
4. 전송 계층: 종단간 통신을 관리함. 신뢰성 있는 데이터 전송이 목적, 시퀸스 넘버 방식의 오류 제어와 분할/분리 등이 포함됨.
5. 세션 계층: 세션을 확립/유지/중단하는 작업을 수행
6. 표현 계층: 데이터의 인코딩/디코딩, 암호화/복호화 등을 수행.
7. 응용 계층: 사용자가 사용하는 응용 프로그램들이 속한 계층

</details>

#### TCP/IP 4계층에 대해서 설명해주세요

<details>
<summary markdown="span">설명</summary>

OSI보다 단순하고 실용적인 계층 구조로 현재 인터넷의 표준이다.

1. 링크 계층: 물리+데이터링크
2. 인터넷 계층: IP
3. 전송 계층
4. 응용 계층: 세션+표현+응용

</details>

#### DNS가 무엇인가요?

<details>
<summary markdown="span">정의</summary>

도메인 네임 시스템의 약어로, 사람이 읽기 쉬운 도메인 네임과 실제로 통신에 필요한 IP 주소를 매핑해주는 시스템으로 계층적이고 탈중앙화의 성격을 지님.

</details>

#### 도메인 이름으로 실제 IP를 어떻게 찾을 수 있는지 흐름을 설명해 주세요

<details>
<summary markdown="span">과정</summary>

반복적인 쿼리를 통해 찾아감. 재귀적인 방식도 있지만 이건 상위 도메인 서버에 과부하를 주기 때문에 쓰지 않음.
여기선 예로 www.google.com을 들자.

1. PC에 설정된 local DNS 서버로 www.google.com에 해당하는 IP 주소를 요청함. (보통 ISP에서 제공하는 서버로 DNS 계층과는 관련 없음.)
2. local DNS 서버는 www.google.com을 모른다면 자신의 루트 DNS 서버에 요청함.
3. 루트 DNS 서버는 맨 끝자리인 com을 가리키는 Top level domain(TLD) 서버의 주소를 local DNS 서버에 반환함.
4. local DNS 서버는 .com TLD 서버에 요청함.
5. .com TLD 서버는 .google.com 에 해당되는 Authoritative DNS 서버를 알고 있다면 해당 서버의 주소를 local DNS 서버에 반환함.
6. local DNS는 .google.com DNS 서버에 요청함.
7. .google.com은 www라는 호스트네임을 알고 있기 때문에 www.google.com에 해당되는 IP 주소를 local DNS에 반환함.
8. local DNS는 www.google.com과 IP 주소를 필요하면 캐싱하고 PC에 IP 주소를 반환함.

</details>

### TCP/UDP

#### TCP와 UDP의 차이에 대해서 설명해 주세요

<details>
<summary markdown="span">차이점</summary>

* TCP: 신뢰성(패킷 손실/중복/순서 바뀜이 없도록 보장), 연결지향적, 흐름제어와 혼잡제어를 함.
* UDP: 비연결성, 오류 정정이나 재송신, 순서 보장을 하지 않음. 그래서 TCP보다 오버헤드가 적고 빠름.

</details>

#### TCP 헤더에 대해서 설명해 주세요

<details>
<summary markdown="span">설명</summary>

* Source Port: 송신 포트
* Destination Port: 수신 포트
* 시퀸스 번호: SYN일 때는 초기 시퀸스 번호, 그 외에는 최초 세그먼트부터의 누적 바이트
* ACK 번호: 수신자가 예상하는 다음 시퀸스 번호(바이트)
* 데이터 오프셋: TCP 헤더의 크기값, 5워드보다 크면 옵션이 존재함.
* Reserved: 미래에 사용하기 위해 남긴 예비 필드
* Flags: 9개의 1비트 플래그, 핸드쉐이크에 사용하는 ACK나 SYN, FIN도 여기서 나타냄.
* Window 크기: 수신 윈도우의 크기
* Checksum
* Urg data pointer
* options

</details>

#### MTU가 무엇인가요?

<details>
<summary markdown="span">설명</summary>

최대 전송 단위, 연결된 네트워크의 수용량에 따르기 때문에 넘지 않도록 주의해야 함.  
outbound MTU보다 큰 패킷이 도착하면 이를 MTU보다 작도록 나눔.(IP Fragmentation)

</details>

#### 3-way hand shake, 4-way hand shake 흐름에 대해서 설명해주세요

<details>
<summary markdown="span">3-way handshake</summary>

TCP에서의 신뢰성있는 연결 시작을 위한 방법  
시작은 서버와 클라이언트 모두 소켓이 열려있음.  

1. 클라이언트가 서버로 SYN 메세지를 보냄, Seq는 시작 번호 x
2. 서버가 클라이언트의 SYN 메세지를 받음.
3. 서버가 클라이언트에서 SYN ACK 메세지를 보냄, Seq는 시작 번호 y, Ack는 x+1
4. 클라이언트가 서버의 SYN ACK 메세지를 받음.
5. 클라이언트가 연결을 수립함.
6. 클라이언트가 서버로 ACK 메세지를 보냄, Ack는 y+1
7. 서버가 클라이언트의 ACK 메세지를 받음.
8. 서버가 연결을 수립함.

</details>

<details>
<summary markdown="span">4-way handshake</summary>

TCP에서의 신뢰성있는 연결 종료를 위한 방법.  
아래에선 클라이언트가 먼저 연결을 끊는 예시지만 반대의 경우는 서버가 먼저 FIN을 보낸다고 생각하면 됨.  

1. 클라이언트가 서버로 FIN 메세지를 보냄, Seq는 번호 x
2. 클라이언트는 전송할 수 없지만 수신할 수 있는 대기 상태가 됨.
3. 서버가 클라이언트의 FIN 메세지를 받고 Ack가 x+1인 ACK 메세지를 보냄.
4. 클라이언트가 ACK 메세지를 받고 서버에서의 연결도 종료되는 걸 기다림.
5. 서버에서 seq가 y인 FIN 메세지를 보냄.
6. 서버도 전송할 수 없는 상태가 됨.
7. 클라이언트가 서버의 FIN 메세지를 받고, ack y+1인 ACK 메세지를 보냄.
8. 서버가 클라언트의 ACK 메세지를 받고 종료됨.
9. 클라이언트는 세그먼트의 최대 lifetime * 2만큼 기다리면서 새 연결을 만들지 않음. 이는 혹시나 서버로부터 지연된 이전 세그먼트가 새 연결 중에 도착하는 문제를 막기 위함.
10. 클라이언트도 종료됨.

</details>

### HTTP

#### HTTP 프로토콜에 대해서 아는대로 말해주세요

<details>
<summary markdown="span">설명</summary>

* 어플리케이션 계층에 있는 리소스 요청 프로토콜
* 클라이언트/서버 모델
* TCP를 사용함.
* 프로토콜 자체엔 상태가 없음. 이전 연결의 정보를 저장하지 않음.
* HTTP 메세지는 사람이 읽을 수 있어서 간단하고 테스트하기 쉬움
* 서버/클라 간의 합의만 있다면 HTTP 헤더는 확장 가능

</details>

#### HTTP와 HTTPS 의 차이는 무엇인가요?

<details>
<summary markdown="span">설명</summary>

HTTPS는 HTTP와 TCP 사이에 암호화 프로토콜인 SSL/TLS로 HTTP 메세지를 암호화해서 전송함.

</details>

#### HTTPS가 동작하는 방식에 대해서 설명해 주세요

<details>
<summary markdown="span">과정</summary>

이 과정은 사용자에겐 노출되지 않는다.  

1. handshake: 사용자가 웹사이트에서 새로운 세션을 시작할 때마다 사용자의 브라우저와 웹사이트 서버는 서로 간 SSL 인증서를 교환하고 검증하게 됨.
    1. 클라이언트가 서버로 클라에서 생성한 랜덤 데이터와 자신이 쓸 수 있는 암호화 방식 목록을 전송함.
    2. 서버가 클라이언트로 목록에서 선택한 암호화 방식과 서버에서 생성한 랜덤 데이터, 인증서를 보냄. 이 다음부턴 서로 이 암호화 방식으로 통신함.
    3. 클라이언트는 서버의 인증서가 CA에서 발급된 건지 확인하기 위해 내장된 CA 리스트를 확인하고 해당 CA의 공개키를 사용해 복호화한다. 복호화에 성공했다면 해당 서버를 신뢰할 수 있음.
    4. 클라이언트는 서버와 자신이 생성한 랜덤 데이터를 조합해서 대칭키를 생성함. 이는 세션 단계에서 데이터를 주고 받을 때 사용하고, 절대 노출되어선 안됨.
    5. 인증서 안에 들어잇는 서버의 공개키로 위의 대칭키를 암호화해서 전송함.
    6. 서버는 클라이언트가 보낸 암호화된 대칭키를 개인키로 복호화해서 얻음.
    7. 클라이언트와 서버는 서로에게 handshake 단계의 종료를 알림.
2. 세션: 데이터를 주고받을 때, handshake 단계에서 만든 대칭키로 암호화하고 복호화함.
3. 세션 종료: 데이터 전송이 끝나면 통신이 끝났음을 서로에게 알리고, 대칭키를 폐기함.

</details>

#### HTTP 1.0과 1.1의 차이는 무엇인가요?

<details>
<summary markdown="span">설명</summary>

1.1에서는 복수의 개체를 하나의 TCP 연결을 통해 보낼 수 있게 되어서 연결 오버헤드를 줄이고, TCP의 혼잡제어의 특징때문에 오래 연결을 유지함으로써 속도가 빨라지는 이점이 있음.

</details>

#### HTTP2와 그 특징에 대해서 설명해 주세요

작성 필요

#### HTTP 헤더의 구조에 대해서 설명해 주세요

작성 필요

#### keep-alive 헤더에 대해서 설명해 주세요

작성 필요

#### HTTP GET과 POST의 차이는 무엇인가요?

<details>
<summary markdown="span">설명</summary>

둘 다 리소스 요청이지만 GET은 URL을 통해 요청을 명시하지만 POST는 요청 객체 안에 포함됨.

GET

* 캐싱이 가능하고, 요청을 URL로 쉽게 공유할 수 있음.
* 내용이 외부에 쉽게 노출되기 때문에 민감한 내용은 이 방법을 사용해선 안됨.
* URL에 포함되기 때문에 길이 제한이 있음.

POST

* 캐싱되지 않음. POST 요청은 공유될 수 없음.
* 데이터 길이 제한은 없음.

</details>

#### 쿠키와 세션에 대해서 설명해 주세요

<details>
<summary markdown="span">설명</summary>

HTTP 프로토콜에서는 상태가 없음. 그래서 쿠키와 세션은 HTTP에 정의되지 않은 클라와 서버가 저장하는 상태임.

쿠키: 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각. 브라우저는 그 데이터 조각들을 저장해 놓았다가, 동일한 서버에 재요청 시 저장된 데이터를 함께 전송합니다. 이를 통해 두 요청이 동일 브라우저에서 왔는지 판별할 수 있고, 로그인 상태 유지에 활용할 수 있습니다. 주로 세션관리, 개인화, 트래킹을 위해 사용됩니다.

세션: 원래 정의는 통신에 필요한 임시 정보를 의미하지만 쿠키와 구분할 땐 쿠키는 클라이언트-사이드 세션, 세션은 서버-사이드 세션을 의미함. 필요 데이터를 서버가 관리하고 클라이언트에는 인증 토큰 정도만 가지고 있다면 이에 해당됨. 그래서 데이터가 서버에만 있어서 보안이 더 좋지만 서버 메모리 공간을 차지하고, 분산 환경에서는 쓰기 어렵다는 문제가 있음. 공간 문제 때문에 연결이 끊어진 후 짧은 시간 내에 폐기됨.

</details>

### 웹

#### 웹브라우저에서 서버로 요청했을 때, 흐름을 설명해주세요  

<details>
<summary markdown="span">설명</summary>

1. 브라우저의 주소창에 URL을 입력함.
2. URL의 도메인 네임 부분을 DNS 서버에서 검색함.
3. DNS 서버에서 해당 도메인 네임의 IP 주소를 찾아서 알려줌.
4. URL 정보가 담긴 HTTP 요청 메세지를 생성함.
5. IP 주소에 해당되는 서버로 TCP 연결을 열고 HTTP 요청 메세지를 전송함.
6. HTTP 요청 메세지를 받은 서버는 URL 정보에 해당되는 데이터를 검색함.
7. 검색된 데이터를 HTTP 응답 메세지에 담아서 TCP 연결로 클라이언트에 전송함.
8. HTTP 응답 메세지 내의 데이터를 웹 브라우저를 통해 출력함.

</details>

#### CORS란 무엇인가요?  

작성 필요

#### 웹 서버와 웹 어플리케이션 서버(WAS)의 차이는 무엇인가요?  

<details>
<summary markdown="span">설명</summary>

* 웹서버: HTTP 요청을 받고 정적 컨텐츠를 제공하거나 동적 컨텐츠를 WAS에 요청함.  
* WAS: 동적 컨텐츠를 생성하거나 서버에 데이터를 저장하는 등의 로직을 실행함.

웹서버는 WAS 대신 정적 컨텐츠를 처리해줌으로써 부담을 줄여줌.  
WAS는 요청이 들어올 때마다 그에 맞는 컨텐츠를 생성해 줌으로써 웹서버가 모든 경우의 수에 대한 컨텐츠를 준비해야 되는 부담을 해결해줌.

</details>

#### REST API에 대해서 설명해 주세요  

<details>
<summary markdown="span">설명</summary>

범용성과 확장성을 보장하기 위해 특정 원칙들을 준수하는 API.

* 일관적인 인터페이스: 자원을 식별할 수 있는 식별자와 행위(method)는 표준화 되어 있음.
  * 자기 기술적: 자원의 내용인 표현 부분은 식별자와 구분해야 하고 형식이 자유로움(HTML, JSON 등등). 하지만 클라이언트가 다룰 수 있도록 충분한 내용이 있어야 한다는 가이드라인은 존재함.
* 클라이언트/서버 구조
* 캐시 가능: 클라-서버 간의 상호 작용 간소화
* 상태가 없음: 요청 간에는 정보를 저장하지 않는다.
* 계층화: 보안이나 로드 밸런싱 등을 클라이언트에는 보이지 않는 곳에서 계층화된 시스템으로 제공함.
* Code on demand(선택사항): 서버에서 Javascript 같은 클라이언트에서 실행 가능한 로직을 전송해줘서 기능을 확장할 수 있음.

</details>

#### API Gateway란 무엇인가요?  

작성 필요

#### API Gateway가 다운되면 모든 API를 사용 못할지도 모르는데, 어떤 방안을 마련해야 할까요?  

작성 필요

## 데이터베이스

### 전산 기본

#### JOIN에 대해서 설명해 주세요

#### 내부 조인과 외부 조인의 차이는 무엇인가요?  

#### 정규화에 대해서 설명해 주세요

#### 파티셔닝과 샤딩에 대해서 설명해 주세요

#### ORM이란 무엇인가요?

#### NoSQL이란 무엇인가요?

#### 스키마란 무엇인가요?

### 인덱스

인덱스란 무엇인가요? 어떻게 동작 하나요?  
인덱스의 알고리즘에는 어떤 것들이 있나요?  
Table Full Scan과 Index Range Scan 을 설명해주세요.  

### 트랜잭션

트랜잭션이란 무엇인가요? 4가지 원칙을 포함해서 설명해 주세요.  
트랜잭션의 격리 수준과 각 수준에서 발생할 수 있는 문제들에 대해 말해보세요.  
공유 락과 배타 락의 차이는 무엇인가요?  
데드락이란 무엇이며, 어떻게 발생할까요?  

## 알고리즘

### 전산 기본

빅오 표기법에 대해서 설명해주세요  
팩토리얼(factorial)을 구현해 보세요(손코딩).  
피보나치 수열 구현 방식 세 가지를 말해보시고, 시간복잡도와 공간복잡도를 설명해 주세요.  
BFS/DFS 차이는 무엇인가요?  
프림 알고리즘에 대해서 설명해 주세요.  
다익스트라 알고리즘에 대해서 설명해 주세요.  

### 정렬

정렬의 종류에는 어떤 것들이 있나요?  
삽입 정렬이 일어나는 과정을 설명해 보세요.  
퀵 정렬이 일어나는 과정을 설명해 보세요.  
54321 배열이 있을 때, 어떤 정렬을 사용하면 좋을까요?  
랜덤으로 배치된 배열이 있을때, 어떤 정렬을 사용하면 좋을까요?  
자릿수가 모두 같은 수가 담긴 배열이 있을 때, 어떤 정렬을 사용하면 좋을까요?  

## 자료구조

### 전산 기본

배열과 링크드 리스트의 차이점에 대해서 설명해 주세요.  
스택과 큐에 대해서 설명해 주세요.  
해시테이블에 대해서 설명해 주세요.  

### 트리

포화(Perfect) 이진트리, 완전(Complete) 이진트리, 정(Full) 이진트리의 차이점에 대해 각각 설명해주세요.  
그래프와 트리의 차이점에 대해서 설명해 주세요.  
힙 자료구조에 대해 설명해 주세요.  
힙의 삽입과 삭제는 어떻게 이루어지나요?  
레드 블랙 트리에 대해 설명해주세요.  
레드 블랙 트리의 삽입과 삭제 과정에 대해서 말해보세요.  
B-Tree에 대해서 설명해 주세요.  
최소 신장 트리에 대해서 설명해 주세요.  

## 프로그래밍

### 전산 기본

#### 재귀호출의 단점

함수 호출마다 시간과 스택 공간의 오버헤드 발생, 로직이 헷갈리기 때문에 문서화나 디버깅/유지보수 등이 어려움.  

객체지향이 무엇인가요? 절차지향과의 차이점은 뭐죠?  
객체지향 SOLID 원칙에 대해서 설명해 주세요.  
객체지향 4가지 특징에 대해서 설명해 주세요.  
대표적인 객체지향 언어에는 어떤 것들이 있나요?  
데이터 타입과 변수의 차이는 무엇인가요?  
함수형 프로그래밍에 대해서 설명해 주세요.  
AOP란 무엇인가요?  
컴파일러와 인터프리터의 차이는 무엇인가요?  
오버로딩과 오버라이딩의 차이는 무엇인가요?  
1급 객체에 대해서 설명해 주세요.  

### JAVA

#### 기본

Java 접근 제어자에 대해서 각각 설명해 주세요.  
JVM의 구조에 대해서 설명해 주세요.  
Garbage Collector 에 대해서 설명해 주세요. 어떻게 동작하나요?  
GC의 종류에 대해서 말해보세요.  
Java 버전 별 특성에 대해서 아는대로 말해주세요.  
Java는 Call By Value일까요, Call By Reference 일까요?  
리플렉션(Reflection)이란 무엇인가요?  
Stream API란 무엇인가요?  
Lambda란 무엇인가요?  
함수형 인터페이스란 무엇인가요?  
JVM 기동시 주로 사용되는 옵션들을 아는대로 말해보세요.  
foreach를 사용할 수 있는 자료구조는 어떤 인터페이스를 상속받고 있나요?  
iterator와 iterable 차이는 무엇인가요?  
synchronized 키워드에 대해 설명해 주세요.  
volatile 키워드에 대해 설명해 주세요.  
final 키워드에 대해서 설명해주세요. 각각의 쓰임에 따라 어떻게 동작하나요?  

#### 클래스와 객체

Wrapper Class란 무엇인가요?  
클래스, 객체, 인스턴스 차이에 대해서 설명해 주세요.  
직렬화(Serialization)과 역직렬화(Deserialization)에 대해서 설명해 주세요.  
Java Generic에 대해서 설명해 주세요.  
equals와 ==의 차이는 무엇인가요?  
hashCode란 무엇인가요?  
문자열을 리터럴(string = "abcd")로 할당하는 것과 객체(string = new String("abcd"))로 할당하는 방식의 차이가 무엇인가요?  
순수 추상 클래스와 인터페이스의 차이는 무엇인가요?  
본인 관점에서, 인터페이스는 주로 어떨 때 사용하나요?  

#### 자료형, 자료구조

Java의 Collection에 대해서 설명해 주세요.  
Array와 ArrayList의 차이점은 무엇인가요?  
char type과 string type으로 나뉘어져 있는 이유는 무엇인가요?  

## Spring Framework

### 기본

Spring이란 무엇인가요?  
Spring, Spring MVC, Spring Boot의 차이점에 대해 각각 설명해 주세요.  
Spring 버전 별 특성에 대해서 아는대로 답변해 주세요.  
Spring Framework의 생명 주기에 대해서 말해주세요.  
Bean이란 무엇인가요?  
Interceptor와 Filter의 차이점을 말해주세요.  
IOC와 DI에 대해서 설명해주세요.  
Container란 무엇인가요?  
VO, DTO, DAO에 대해서 각각 설명해 주세요.  

### MVC

MVC에 대해서 설명해 주세요.  
Servlet이 무엇인가요? (사실 이건 Java 섹션에 있는게 맞음..)  
Dispatcher-Servlet이란 무엇인가요?  
Spring MVC에서 HTTP 요청이 들어왔을 때의 흐름을 설명해 주세요.  

## Design Pattern

디자인패턴
어댑터 패턴
싱글톤 패턴
템플릿 메소드 패턴
팩토리 메소드 패턴
추상 팩토리 패턴
옵저버 패턴
스트레티지 패턴
데코레이터 패턴
컴포지트 패턴
방문자 패턴
퍼사드 패턴

## ETC

### 전산 기본

TDD란 무엇인가요?  
프레임워크와 라이브러리 차이는 무엇인가요?  
디자인 패턴이란 무엇인가요?  
Monolitc Architecture, Micro Service Architecture에 대해 각각 설명해 주세요.  
애자일 방법론이란?  
도커란 무엇인가요?  

## 참조

### 질문 목록

* [기술면접 준비하기 - hygoogi](https://velog.io/@hygoogi/%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C)
* 프로그래밍 면접 이렇게 준비한다 - 존 몽건 외 2명, 한빛미디어

### 답변

* Wikipedia
* [해시넷](http://wiki.hash.kr/)
* [StudyTonight-OS tutorial](https://www.studytonight.com/operating-system/)
* [동기비동기블로킹논블로킹 IO - 배철오](https://www.slideshare.net/unitimes/sync-asyncblockingnonblockingio)
* Operating System Internals and Design Principles 8th edition - William Stallings, Pearson
* [TTA 정보통신용어사전](https://terms.tta.or.kr/)
* [정보통신기술용어해설](http://www.ktword.co.kr/)
* [MDN](https://developer.mozilla.org/)
* [생활코딩](https://www.opentutorials.org/)
* [W3Schools](https://www.w3schools.com/)
* [TCP School](http://tcpschool.com/)
* [레드햇](https://www.redhat.com/)
* [NHN Cloud meetup](https://meetup.toast.com/)
