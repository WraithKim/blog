---
layout: post
title:  "분노의 기술 면접 준비"
categories: tech-interview
---

* toc
{:toc}

## 운영체제

### 프로세스

#### 프로세스와 스레드의 차이는 무엇인가요?

<details>
<summary markdown="span">정의</summary>

프로그램: 어떤 작업을 위해 실행할 수 있는 파일

프로세스: 실행되고 있는 프로그램의 인스턴스. 하나 또는 여러개의 쓰레드와 관련된 시스템 자원(코드나 데이터/열린 파일 등을 가진 메모리 공간)의 집합.

쓰레드: dispatch 가능한 작업의 단위, 프로세서 컨텍스트(PC, Stack Pointer 등)와 데이터 영역인 stack을 가지고 있음. 쓰레드는 순차적으로 실행되고, 인터럽트 가능해서 다른 스레드로 전환될 수 있음.

</details>

<details>
<summary markdown="span">차이점</summary>

1. 프로세스는 보통 독립적이지만 쓰레드는 프로세스에 속해있음.
2. 프로세스는 쓰레드보다 더 많은 상태 정보를 가지고 있음. 쓰레드는 이 자원들은 프로세스로부터 공유받음.
3. 컨텍스트 스위칭은 프로세스 사이보다 쓰레드 사이가 더 빠름.
4. 멀티 쓰레드가 멀티 프로세스보다 자원 소비가 적음.
5. 프로세스는 분리된 주소 공간을 가짐. 쓰레드는 자기들의 주소 공간을 공유함. 그래서 한 쓰레드의 오류가 다른 쓰레드에 영향을 줄 수 있음.
6. 프로세스 간 상호작용은 IPC나 메세지 패싱 등을 사용해야 해서 복잡함. 쓰레드는 서로 이미 공유하는 파일이나 데이터로 할 수 있어서 간단함.

</details>

#### 교착상태란 무엇이며, 교착상태가 발생하기 위해서는 어떤 조건이 있어야 하나요?

<details>
<summary markdown="span">정의</summary>

한 그룹의 각 멤버가 행동하기 위해 자신을 포함한 다른 멤버를 기다리고 있는 상태

</details>

<details>
<summary markdown="span">조건</summary>

교착상태는 아래의 조건을 모두 만족하는 것과 동일함.

1. Mutual exclusion: 한 시점에 한 프로세스만 사용 가능한 자원
2. Hold and wait: 프로세스가 한 자원을 소유하는 중에 다른 프로세스가 들고 있는 자원을 요청함.
3. No preemption: 자원은 소유하고 있는 프로세스만 반환할 수 있음.
4. Circular wait: 각 프로세스는 반드시 다른 프로세스의 자원을 기다리고 있음.

</details>

<details>
<summary markdown="span">기타 지식</summary>

Starvation: 특정 프로세스가 자신에게 필요한 자원을 영구적으로 거부당하고 있는 상태
LiveLock: 프로세스의 상태는 바뀌지만 진행되지 않는 상태

</details>

#### 교착상태의 해결법은 무엇인가요?

<details>
<summary markdown="span">해결법</summary>

1. 무시: 교착상태가 일어나지 않을 거라 간주하고 감지나 예방 방법을 적용하지 않음.
2. 감지: 교착상태가 발생했는지 감지함. 감지되면 관련된 프로세스를 전부 종료하거나 체크포인트로 되돌리기, 순차적으로 자원을 선점시키기 등으로 회복함.
3. 예방: 교착상태가 일어나지 않도록 4원칙 중 하나라도 만족할 수 없는 시스템 설계, 비효율적
4. 회피: 동적으로 교착상태가 발생할 수 있는 자원 접근을 차단함. 은행원 알고리즘.

</details>

#### 은행원 알고리즘

설명이 좋은 글로 대체함.  
<https://jhnyang.tistory.com/102>

#### 뮤텍스와 세마포어에 대해서 설명해 보시오

<details>
<summary markdown="span">설명</summary>

* 뮤텍스: 자원을 사용할 때 특정 변수의 소유권을 가져오고, 끝나면 소유권을 반환하는 방식의 상호배제 기법  
* 세마포어: 동시에 자원을 사용할 수 있는 수를 나타내는 값을 두고 증감시키는 방식의 상호배제 기법

</details>

#### 컨텍스트 스위칭이란 무엇인가요?

<details>
<summary markdown="span">정의</summary>

나중에 복원되거나 실행을 재개하기 위해 프로세스나 쓰레드의 상태를 저장하는 과정  
멀티태스킹, 인터럽트 핸들링, 유저/커널 모드 스위칭의 경우가 있음.

</details>

<details>
<summary markdown="span">순서</summary>

1. 프로세스가 사용한 레지스터 값이 포함된 프로세스의 상태를 PCB에 저장함.
2. PCB 대한 핸들을 프로세스 실행 대기열인 ready queue에 추가함.
3. OS가 현재 프로세스를 끝내면 ready queue에서 다음 프로세스를 선택하고 PCB를 복구함. 프로그램 카운터가 PCB를 통해 불러와지고, 다음 프로세스가 재개됨.

</details>

#### PC와 PID

<details>
<summary markdown="span">설명</summary>

* PC: 프로그램 카운터, 다음에 실행될 명령어의 주소가 들어있는 레지스터  
* PCB: 프로세스 제어 블록, 프로세스의 중요 정보 저장/context switching에 사용, PID/상태/PC값 등을 담고 있음.

</details>

#### 경쟁 상태란 무엇인가요?

<details>
<summary markdown="span">설명</summary>

여러 개의 프로세스나 쓰레드가 데이터를 읽고 쓰는 과정에서 최종 결과가 명령어의 실행된 순서에 의해 결정되는 것.

</details>

#### 프로세스 혹은 스레드의 동기화란 무엇인가요?

<details>
<summary markdown="span">설명</summary>

* 동기화: 동시에 두 개 이상의 쓰레드나 프로세스가 크리티컬 세션을 동시에 실행하지 않도록 하는 방법들  
* 크리티컬 세션: 공유 자원에 대한 동시 접근을 막아야 되는 프로그램 영역.

</details>

#### 사용자 수준의 스레드와 커널 수준의 스레드의 차이는 무엇인가요?

작성 필요

#### CPU 스케줄링이란 무엇인가요?

<details>
<summary markdown="span">정의</summary>

멀티태스킹 환경에서 효율적이고 빠르고 공평하게 시스템을 쓸 수 있도록 CPU에 작업을 할당하는 과정

</details>

#### CPU 스케줄링 방법에는 대표적으로 어떤 것들이 있나요?

<details>
<summary markdown="span">방법들</summary>

* First Come First Serve: convoy effect 발생(앞에 긴 작업 때문에 뒤의 짧은 작업들이 밀려서 OS 전체가 느려짐.)
* Priority Scheduling: FCFS에 우선순위를 둠. 예시로 Realtime OS에서 시간제한을 기준으로 함.
* Shortest Job First: 실행시간이 짧은 작업 우선(비선점)
* Highest Response Ratio Next: 대기시간/예상작업시간 으로 우선순위를 정함.(비선점)
* Shortest Remaining Time First: 예상 완료시간이 가장 짧은 프로세스를 선택함. 만약 새로 들어온 작업이 실행 중인 작업보다 빨리 끝난다면 교체함.(선점)
* Longest Remaining Time First: SRTF의 반대
* Round Robin: 단위 시간으로 쪼개서 정해진 시간이 지나면 다음 프로세스가 선점하게 함.
* Multilevel Queue Scheduling: 프로세스를 쉽게 나눠지는 기준으로 나누고 각각에 다른 스케쥴링을 적용함. ex) foreground/background
* Multilevel Feedback Queue Scheduling: 프로세스가 그룹 사이를 옮길 수 있어야 할 때 사용함. ex) low/high priority queue를 만들어서 프로세스의 상태에 따라 옮김.

SJF 계열은 프로세스의 정확한 실행시간을 미리 알 수 있어야 된다는 점 때문에 실생활에선 보기 힘듦.

</details>

<details>
<summary markdown="span">기타 지식 - 스케쥴러의 종류</summary>

* 장기 스케쥴러: ready queue에 들어갈 프로세스를 결정함.
* 중기 스케쥴러: 페이지 교체를 결정함.
* 단기 스케쥴러: ready queue에서 CPU에 할당될 프로세스를 결정함. <- CPU scheduler

</details>

#### 동기와 비동기, 블로킹과 넌블로킹의 차이는 무엇인가요?

<details>
<summary markdown="span">차이점</summary>

Thread가 아닌 IO 관점에서 서술함.  

* 동기/비동기: 시스템 콜의 완료를 기다리는가, 즉시 리턴되는가
* 블로킹/넌블로킹: 대기큐에 들어가는가/시스템콜이 완료된 후에 오는가
* 비동기/넌블로킹: 시스템콜이 즉시 리턴될 때, 0이든 일부든 전부든 간에 데이터가 오면 넌블로킹/안오면 비동기
* 동기/블로킹: 시스템 콜이 끝날 때까지 대기 큐에 들어가지 않는가? (비동기 IO의 spinning이 동기와 유사함.)

||동기|블로킹|비동기|넌블로킹|
|-|-|-|-|-|
|시스템 콜 기다림|O|O|X|X|
|즉시 반환됨|X|X|O|O|
|데이터와 함께 반환됨|O|O|X|O|
|대기 큐에서 기다림|X|O|X|X|

</details>

### 메모리

#### C에서 메모리를 어떻게 할당하는가?

<details>
<summary markdown="span">할당 방법</summary>

* 정적 할당: 프로그램 시작 시 정해진 메모리를 할당함. 스택. 메모리 누수 없음. 할당된 크기는 조절 불가  
* 동적 할당: 런타임 중 할당함, 다른 스레드가 사용하지 못하게 예약해버림. 힙. 상황에 따라 자유롭게 할당하고 조절할 수 있음. 직접 해제해야 한다면 메모리 누수 문제, GC를 쓴다면 성능 저하가 있음.

</details>

#### 프로세스에 할당되는 메모리의 각 영역에 대해서 설명해 주세요

<details>
<summary markdown="span">프로세스 내 메모리 구조</summary>

1. 스택: 낮은 메모리 주소 방향으로 자라남, 지역변수/매개변수/반환값 등
2. 힙: 높은 메모리 주소 방향으로 자라남, 동적으로 메모리를 할당하는 곳, 프로세스 내의 모든 쓰레드, 동적 모듈, 공유 라이브러리들이 공유함.
3. BSS: 정적으로 정의되었지만 초기값이 없는 변수들.
4. 데이터: 정적으로 정의된 값들, 전역변수/정적변수/상수/구조체
5. 코드(텍스트): 명령어가 들어감, 고정된 크기

</details>

#### 메모리 구조의 순서가 어떻게 되는가? CPU에서 가까운 순으로 말해보시오

<details>
<summary markdown="span">메모리 계층</summary>

내려갈 수록 비트당 비용이 줄고, 접근 시간과 용량이 늘어남. 접근하는 빈도가 적음.

1. Inboard Memory: 레지스터, 캐시, 메인 메모리
2. Outboard Memory: 보조기억장치
3. Off-line Storage: 사람에 의해 연결/제거가 가능한 보조기억장치, Flash Drive, 광학 디스크

</details>

#### 페이지와 세그멘테이션에 대해서 설명해 보시오

<details>
<summary markdown="span">페이징</summary>

* 프레임: 주기억장치의 고정 길이 블록, 프레임 번호와 오프셋으로 구성됨.  
* 페이지: 보조기억장치에 저장된 데이터의 고정 길이 블록, 페이지 번호와 오프셋으로 구성됨.
* 페이지 테이블: 페이지 번호 순으로 해당되는 프레임 번호가 있음.
* 페이징: 페이지를 사용한 메모리 관리 방법. 프로세스에 페이지 테이블을 선언해서 프로세스의 프레임이 연속되지 않더라도 페이지 테이블과 논리 주소를 통해 빠르게 접근할 수 있게 함. 외부 단편화는 없지만 내부 단편화가 존재

</details>

<details>
<summary markdown="span">세그멘테이션</summary>

* 세그멘트: 보조기억장치에 저장된 가변 길이 블록, 세그멘트 번호와 오프셋으로 구성됨.
* 세그멘트 테이블: 세그멘트 번호 순으로 해당되는 세그멘트의 길이와 시작 주소가 있음.
* 세그멘테이션: 세그멘트를 사용한 메모리 관리 방법. 프로세스에 세그멘트 테이블을 선언해서 프로세스가 여러 파티션으로 나뉘더라도 빠르게 접근할 수 있게 함. 내부 단편화는 없지만 외부 단편화가 존재

</details>

#### 외부 단편화란? 내부 단편화란?

<details>
<summary markdown="span">정의</summary>

* 내부 단편화: 데이터가 할당된 파티션의 크기보다 불러온 데이터의 크기가 작아서 낭비된 공간이 존재함.  
* 외부 단편화: 메모리에서 파티션을 제외한 나머지 공간이 잘게 쪼개짐.

</details>

#### First Fit, Best Fit, Worst Fit에 대해서 설명해 보시오

<details>
<summary markdown="span">설명</summary>

OS가 프로세스를 메모리에 할당할 때 여유 공간들 중 선택하는 알고리즘

* First Fit: 메모리 시작부터 스캔해서 프로세스를 담을 수 있을 정도의 크기의 첫번째 블록에 할당
* Best Fit: 프로세스의 크기에 가장 가까운 크기의 블록에 할당
* Next Fit: 이전에 할당한 위치부터 프로세스를 담을 수 있는 다음 블록에 할당.

</details>

#### 페이지 교체 알고리즘 종류에는 어떤 것들이 있나요?

<details>
<summary markdown="span">정의와 종류</summary>

더 이상 주기억장치에 공간이 없을 때, 새 페이지와 자리를 교체할 기존 페이지를 결정하는 알고리즘

* Optimal: 가장 페이지 폴트가 적게 나도록 교체하는 방법. 미래 예측이 가능하지 않는 이상 구현 불가.  
* LRU: 가장 오래전에 참조된 페이지를 교체함. 참조 기록이 필요함.  
* FIFO: 가장 오래전에 메모리에 적재된 페이지를 교체함.  
* Clock: 모든 페이지를 원형 버퍼에 넣고 페이지가 들어오거나 참조되면 비트를 1로 바꿈. 페이지를 교체할 때가 되면, 버퍼를 스캔해서 비트가 0인 페이지를 교체함. 버퍼에 갱신이 일어나면 포인터를 다음으로 옮기고 가리킨 페이지의 비트를 0으로 바꿈.  

</details>

#### 캐시 메모리

작성 필요

## 네트워크

### 전산 기본

#### OSI 7계층에 대해서 설명해주세요

<details>
<summary markdown="span">설명</summary>

여러 네트워크 장비들의 상호호환성을 위해 네트워크 프로토콜을 특징에 따라 7계층으로 분류한 기준  
전기 신호에서 프로그램이 인식할 수 있는 데이터가 되기까지의 네트워크 흐름이 정의되어 있음. 데이터는 각 계층을 지날 때마다 캡슐화됨.  
계층으로 정의되었기 때문에 인접한 계층에만 의존한다는 점과 오류 파악이 용이하다는 장점이 있다.

1. 물리 계층: 전기 신호를 전달하고 읽는 역할. 유무선 통신 기술이 포함됨.
2. 데이터 링크 계층: 직접 연결된 노드 간 통신을 관리함. 물리 장치를 식별할 수 있는 주소 지정과 오류 감지, 흐름 제어를 함.
3. 네트워크 계층: 네트워크 간 통신을 관리함. 논리 주소인 IP를 확인하며 라우팅과 포워딩을 주로 수행함.
4. 전송 계층: 종단간 통신을 관리함. 신뢰성 있는 데이터 전송이 목적, 시퀸스 넘버 방식의 오류 제어와 분할/분리 등이 포함됨.
5. 세션 계층: 세션을 확립/유지/중단하는 작업을 수행
6. 표현 계층: 데이터의 인코딩/디코딩, 암호화/복호화 등을 수행.
7. 응용 계층: 사용자가 사용하는 응용 프로그램들이 속한 계층

</details>

#### TCP/IP 4계층에 대해서 설명해주세요

<details>
<summary markdown="span">설명</summary>

OSI보다 단순하고 실용적인 계층 구조로 현재 인터넷의 표준이다.

1. 링크 계층: 물리+데이터링크
2. 인터넷 계층: IP
3. 전송 계층
4. 응용 계층: 세션+표현+응용

</details>

#### DNS가 무엇인가요?

<details>
<summary markdown="span">정의</summary>

도메인 네임 시스템의 약어로, 사람이 읽기 쉬운 도메인 네임과 실제로 통신에 필요한 IP 주소를 매핑해주는 시스템으로 계층적이고 탈중앙화의 성격을 지님.

</details>

#### 도메인 이름으로 실제 IP를 어떻게 찾을 수 있는지 흐름을 설명해 주세요

<details>
<summary markdown="span">과정</summary>

반복적인 쿼리를 통해 찾아감. 재귀적인 방식도 있지만 이건 상위 도메인 서버에 과부하를 주기 때문에 쓰지 않음.
여기선 예로 www.google.com을 들자.

1. PC에 설정된 local DNS 서버로 www.google.com에 해당하는 IP 주소를 요청함. (보통 ISP에서 제공하는 서버로 DNS 계층과는 관련 없음.)
2. local DNS 서버는 www.google.com을 모른다면 자신의 루트 DNS 서버에 요청함.
3. 루트 DNS 서버는 맨 끝자리인 com을 가리키는 Top level domain(TLD) 서버의 주소를 local DNS 서버에 반환함.
4. local DNS 서버는 .com TLD 서버에 요청함.
5. .com TLD 서버는 .google.com 에 해당되는 Authoritative DNS 서버를 알고 있다면 해당 서버의 주소를 local DNS 서버에 반환함.
6. local DNS는 .google.com DNS 서버에 요청함.
7. .google.com은 www라는 호스트네임을 알고 있기 때문에 www.google.com에 해당되는 IP 주소를 local DNS에 반환함.
8. local DNS는 www.google.com과 IP 주소를 필요하면 캐싱하고 PC에 IP 주소를 반환함.

</details>

### TCP/UDP

#### TCP와 UDP의 차이에 대해서 설명해 주세요

<details>
<summary markdown="span">차이점</summary>

* TCP: 신뢰성(패킷 손실/중복/순서 바뀜이 없도록 보장), 연결지향적, 흐름제어와 혼잡제어를 함.
* UDP: 비연결성, 오류 정정이나 재송신, 순서 보장을 하지 않음. 그래서 TCP보다 오버헤드가 적고 빠름.

</details>

#### TCP 헤더에 대해서 설명해 주세요

<details>
<summary markdown="span">설명</summary>

* Source Port: 송신 포트
* Destination Port: 수신 포트
* 시퀸스 번호: SYN일 때는 초기 시퀸스 번호, 그 외에는 최초 세그먼트부터의 누적 바이트
* ACK 번호: 수신자가 예상하는 다음 시퀸스 번호(바이트)
* 데이터 오프셋: TCP 헤더의 크기값, 5워드보다 크면 옵션이 존재함.
* Reserved: 미래에 사용하기 위해 남긴 예비 필드
* Flags: 9개의 1비트 플래그, 핸드쉐이크에 사용하는 ACK나 SYN, FIN도 여기서 나타냄.
* Window 크기: 수신 윈도우의 크기
* Checksum
* Urg data pointer
* options

</details>

#### MTU가 무엇인가요?

<details>
<summary markdown="span">설명</summary>

최대 전송 단위, 연결된 네트워크의 수용량에 따르기 때문에 넘지 않도록 주의해야 함.  
outbound MTU보다 큰 패킷이 도착하면 이를 MTU보다 작도록 나눔.(IP Fragmentation)

</details>

#### 3-way hand shake, 4-way hand shake 흐름에 대해서 설명해주세요

<details>
<summary markdown="span">3-way handshake</summary>

TCP에서의 신뢰성있는 연결 시작을 위한 방법  
시작은 서버와 클라이언트 모두 소켓이 열려있음.  

1. 클라이언트가 서버로 SYN 메세지를 보냄, Seq는 시작 번호 x
2. 서버가 클라이언트의 SYN 메세지를 받음.
3. 서버가 클라이언트에서 SYN ACK 메세지를 보냄, Seq는 시작 번호 y, Ack는 x+1
4. 클라이언트가 서버의 SYN ACK 메세지를 받음.
5. 클라이언트가 연결을 수립함.
6. 클라이언트가 서버로 ACK 메세지를 보냄, Ack는 y+1
7. 서버가 클라이언트의 ACK 메세지를 받음.
8. 서버가 연결을 수립함.

</details>

<details>
<summary markdown="span">4-way handshake</summary>

TCP에서의 신뢰성있는 연결 종료를 위한 방법.  
아래에선 클라이언트가 먼저 연결을 끊는 예시지만 반대의 경우는 서버가 먼저 FIN을 보낸다고 생각하면 됨.  

1. 클라이언트가 서버로 FIN 메세지를 보냄, Seq는 번호 x
2. 클라이언트는 전송할 수 없지만 수신할 수 있는 대기 상태가 됨.
3. 서버가 클라이언트의 FIN 메세지를 받고 Ack가 x+1인 ACK 메세지를 보냄.
4. 클라이언트가 ACK 메세지를 받고 서버에서의 연결도 종료되는 걸 기다림.
5. 서버에서 seq가 y인 FIN 메세지를 보냄.
6. 서버도 전송할 수 없는 상태가 됨.
7. 클라이언트가 서버의 FIN 메세지를 받고, ack y+1인 ACK 메세지를 보냄.
8. 서버가 클라언트의 ACK 메세지를 받고 종료됨.
9. 클라이언트는 세그먼트의 최대 lifetime * 2만큼 기다리면서 새 연결을 만들지 않음. 이는 혹시나 서버로부터 지연된 이전 세그먼트가 새 연결 중에 도착하는 문제를 막기 위함.
10. 클라이언트도 종료됨.

</details>

### HTTP

#### HTTP 프로토콜에 대해서 아는대로 말해주세요

<details>
<summary markdown="span">설명</summary>

* 어플리케이션 계층에 있는 리소스 요청 프로토콜
* 클라이언트/서버 모델
* TCP를 사용함.
* 프로토콜 자체엔 상태가 없음. 이전 연결의 정보를 저장하지 않음.
* HTTP 메세지는 사람이 읽을 수 있어서 간단하고 테스트하기 쉬움
* 서버/클라 간의 합의만 있다면 HTTP 헤더는 확장 가능

</details>

#### HTTP와 HTTPS 의 차이는 무엇인가요?

<details>
<summary markdown="span">설명</summary>

HTTPS는 HTTP와 TCP 사이에 암호화 프로토콜인 SSL/TLS로 HTTP 메세지를 암호화해서 전송함.

</details>

#### HTTPS가 동작하는 방식에 대해서 설명해 주세요

<details>
<summary markdown="span">과정</summary>

이 과정은 사용자에겐 노출되지 않는다.  

1. handshake: 사용자가 웹사이트에서 새로운 세션을 시작할 때마다 사용자의 브라우저와 웹사이트 서버는 서로 간 SSL 인증서를 교환하고 검증하게 됨.
    1. 클라이언트가 서버로 클라에서 생성한 랜덤 데이터와 자신이 쓸 수 있는 암호화 방식 목록을 전송함.
    2. 서버가 클라이언트로 목록에서 선택한 암호화 방식과 서버에서 생성한 랜덤 데이터, 인증서를 보냄. 이 다음부턴 서로 이 암호화 방식으로 통신함.
    3. 클라이언트는 서버의 인증서가 CA에서 발급된 건지 확인하기 위해 내장된 CA 리스트를 확인하고 해당 CA의 공개키를 사용해 복호화한다. 복호화에 성공했다면 해당 서버를 신뢰할 수 있음.
    4. 클라이언트는 서버와 자신이 생성한 랜덤 데이터를 조합해서 대칭키를 생성함. 이는 세션 단계에서 데이터를 주고 받을 때 사용하고, 절대 노출되어선 안됨.
    5. 인증서 안에 들어잇는 서버의 공개키로 위의 대칭키를 암호화해서 전송함.
    6. 서버는 클라이언트가 보낸 암호화된 대칭키를 개인키로 복호화해서 얻음.
    7. 클라이언트와 서버는 서로에게 handshake 단계의 종료를 알림.
2. 세션: 데이터를 주고받을 때, handshake 단계에서 만든 대칭키로 암호화하고 복호화함.
3. 세션 종료: 데이터 전송이 끝나면 통신이 끝났음을 서로에게 알리고, 대칭키를 폐기함.

</details>

#### HTTP 1.0과 1.1의 차이는 무엇인가요?

<details>
<summary markdown="span">설명</summary>

* 같은 문서에 포함된 자원들을 가져올 때 연결을 재사용함.
* 파이프라인이 추가됨. 이제 첫번째 응답이 전부 전송되기 전에 두번째 요청을 보낼 수 있음.
* 청크된 응답 지원
* 캐시 제어 매커니즘이 추가됨.
* 언어, 인코딩 혹은 타입을 포함한 컨텐츠 협상이 도입되어서 클라이언트와 서버 간의 컨텐츠 형식을 맞출 수 있음.
* Host 헤더가 추가됨. 동일 IP 주소에 다른 도메인을 호스팅하는 기능이 가능해짐.

</details>

#### HTTP2와 그 특징에 대해서 설명해 주세요

<details>
<summary markdown="span">설명</summary>

* 텍스트가 아닌 바이너리 프레임으로 나눠짐. 읽을 수 없어졌지만 대신 최적화가 더 적용됨.
* 프레임으로 나눠진 덕분에 하나의 연결로도 병렬 전송이 가능함. 그리고 순서 없이 전송해도 클라에서 다시 조립 가능.
* 헤더를 압축하고, 중복된 헤더를 여러번 전송하지 않아도 됨.
* 서버에서 클라가 요청하지 않은 것도 보낼 수 있는 서버 푸쉬 추가.

</details>

#### HTTP 헤더의 구조에 대해서 설명해 주세요

작성 필요

#### keep-alive 헤더에 대해서 설명해 주세요

작성 필요

#### HTTP GET과 POST의 차이는 무엇인가요?

<details>
<summary markdown="span">설명</summary>

GET

* 리소스를 받아오기 위한 메서드.
* 서버의 상태를 바꾸지 않기 때문에 캐싱이 가능함.
* URL에 매개변수를 포함시켜서 보냄.
* 요청 내용을 URL로 쉽게 공유할 수 있음. 하지만 내용이 외부에 쉽게 노출되기 때문에 민감한 내용은 포함해서는 안됨.
* URL에 포함되기 때문에 길이 제한이 있음.

POST

* 데이터를 보내서 서버에서 처리해 달라고 요청하는 메서드.
* 서버의 상태가 변경되므로 캐싱되지 않음.
* 요청 바디를 통해 데이터를 전달할 수 있음.
* 데이터 길이 제한은 없음.

</details>

<details>
<summary markdown="span">기타지식</summary>

* PUT: 새로운 리소스를 만들거나 기존 리소스를 전체 교체. 두 번 이상 호출되더라도 같은 결과를 내는 멱등성이 있음.
* PATCH: 기존 리소스의 일부를 업데이트. 따라서 멱등성이 없음.
* DELETE: 리소스 삭제

</details>

#### 쿠키와 세션에 대해서 설명해 주세요

<details>
<summary markdown="span">설명</summary>

HTTP 프로토콜에서는 상태가 없음. 그래서 쿠키와 세션은 HTTP에 정의되지 않은 클라와 서버가 저장하는 상태임.

쿠키: 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각. 브라우저는 그 데이터 조각들을 저장해 놓았다가, 동일한 서버에 재요청 시 저장된 데이터를 함께 전송합니다. 이를 통해 두 요청이 동일 브라우저에서 왔는지 판별할 수 있고, 로그인 상태 유지에 활용할 수 있습니다. 주로 세션관리, 개인화, 트래킹을 위해 사용됩니다.

세션: 원래 정의는 통신에 필요한 임시 정보를 의미하지만 쿠키와 구분할 땐 쿠키는 클라이언트-사이드 세션, 세션은 서버-사이드 세션을 의미함. 필요 데이터를 서버가 관리하고 클라이언트에는 인증 토큰 정도만 가지고 있다면 이에 해당됨. 그래서 데이터가 서버에만 있어서 보안이 더 좋지만 서버 메모리 공간을 차지하고, 분산 환경에서는 쓰기 어렵다는 문제가 있음. 공간 문제 때문에 연결이 끊어진 후 짧은 시간 내에 폐기됨.

</details>

### 웹

#### 웹브라우저에서 서버로 요청했을 때, 흐름을 설명해주세요  

<details>
<summary markdown="span">설명</summary>

1. 브라우저의 주소창에 URL을 입력함.
2. URL의 도메인 네임 부분을 DNS 서버에서 검색함.
3. DNS 서버에서 해당 도메인 네임의 IP 주소를 찾아서 알려줌.
4. URL 정보가 담긴 HTTP 요청 메세지를 생성함.
5. IP 주소에 해당되는 서버로 TCP 연결을 열고 HTTP 요청 메세지를 전송함.
6. HTTP 요청 메세지를 받은 서버는 URL 정보에 해당되는 데이터를 검색함.
7. 검색된 데이터를 HTTP 응답 메세지에 담아서 TCP 연결로 클라이언트에 전송함.
8. HTTP 응답 메세지 내의 데이터를 웹 브라우저를 통해 출력함.

</details>

#### CORS란 무엇인가요?  

브라우저가 다른 출처의 리소스를 요청할 때, 해당 출처에서 브라우저에게 리소스 요청 권한이 있는지 알려주는 체제

#### 웹 서버와 웹 어플리케이션 서버(WAS)의 차이는 무엇인가요?  

<details>
<summary markdown="span">설명</summary>

* 웹서버: HTTP 요청을 받고 정적 컨텐츠를 제공하거나 동적 컨텐츠를 WAS에 요청함.  
* WAS: 동적 컨텐츠를 생성하거나 서버에 데이터를 저장하는 등의 로직을 실행함.

웹서버는 WAS 대신 정적 컨텐츠를 처리해줌으로써 부담을 줄여줌.  
WAS는 요청이 들어올 때마다 그에 맞는 컨텐츠를 생성해 줌으로써 웹서버가 모든 경우의 수에 대한 컨텐츠를 준비해야 되는 부담을 해결해줌.

</details>

#### REST API에 대해서 설명해 주세요  

<details>
<summary markdown="span">설명</summary>

REST는 자원을 정의하고 자원에 대한 주소를 지정하는 방법들을 모아둔 원칙 세트.

* 일관적인 인터페이스: 자원을 식별할 수 있는 식별자와 행위(method)는 표준화 되어 있음.
  * 자기 기술적: 자원의 내용인 표현 부분은 식별자와 구분해야 하고 형식이 자유로움(HTML, JSON 등등). 하지만 클라이언트가 다룰 수 있도록 충분한 내용이 있어야 한다는 가이드라인은 존재함.
* 클라이언트/서버 구조
* 캐시 가능: 클라-서버 간의 상호 작용 간소화
* 상태가 없음: 요청 간에는 정보를 저장하지 않는다.
* 계층화: 보안이나 로드 밸런싱 등을 클라이언트에는 보이지 않는 곳에서 계층화된 시스템으로 제공함.
* Code on demand(선택사항): 서버에서 Javascript 같은 클라이언트에서 실행 가능한 로직을 전송해줘서 기능을 확장할 수 있음.

</details>

#### API Gateway란 무엇인가요?  

작성 필요

#### API Gateway가 다운되면 모든 API를 사용 못할지도 모르는데, 어떤 방안을 마련해야 할까요?  

작성 필요

## 데이터베이스

### 전산 기본

#### JOIN에 대해서 설명해 주세요

하나 또는 여러 개의 테이블에서 열을 조합해 새 테이블을 만드는 연산. 일반적으로 SQL에선 INNER, LEFT OUTER, RIGHT OUTER, FULL OUTER 그리고 CROSS를 지원함.

#### 내부 조인과 외부 조인의 차이는 무엇인가요?  

내부 조인은 열 값이 같은 두 테이블의 행만 가져온다.  
외부 조인은 일치하는 열이 존재하지 않더라도 행을 가져온다.

#### 정규화에 대해서 설명해 주세요

보통 RDB에서 데이터 중복을 줄이고 데이터 무결성(정확성과 일관성을 보장하는 유지보수성)을 높이기 위해 DB를 구조화하는 프로세스

#### 파티셔닝과 샤딩에 대해서 설명해 주세요

파티셔닝은 논리적인 데이터베이스를 나누는 것으로, 유지보수나 성능, 가용성 측면에서 이득을 볼 수 있다. 샤딩은 수평 파티셔닝을 통해 다른 서버로 분리될 경우를 의미함.  

수평 파티셔닝: 행들을 묶어서 다른 테이블로 나누는 것을 의미함. 예로 들어 거주자 테이블에서 지역별로 거주자들을 나누는 걸 들 수 있음.  

수직 파티셔닝: 열을 기준으로 나누는 것을 의미한다. 예로 들어 자주 요청되는 열과 그렇지 않은 열을 Primary key만 놓고 다른 테이블로 분리하면, 대부분의 요청에서 쿼리 시간을 줄일 수 있다.  

#### ORM이란 무엇인가요?

ORM은 RDB의 데이터를 OOP 언어로 다룰 수 있도록 하는 기술이다.

#### NoSQL이란 무엇인가요?

특정 데이터 모델에 대해 특정 목적에 맞추어 구축되는 데이터베이스로 대용량, 비정형, 빠르게 바뀌는 데이터에 대해 RDB보다 유연하게 대응하기 위해 만들어졌다.

* 관계형 모델을 사용하지 않음. JOIN 연산도 없음.
* Key-value, Graph, Document 등 다양한 형태의 NoSQL 존재
* 대용량 데이터 저장 가능
* 고정되지 않은 테이블 스키마: ID를 제외하면 동일하지 않아도 됨.
* 여러 서버로 분할해서 수평적 확장이 가능
* 특정 데이터 모델에 최적화된 구조와 기능을 가지기 때문에 성능이 좋고 기능이 더 뛰어남.

#### CAP 이론

분산 환경에서 전부 만족할 수 없는 세 개의 속성을 의미함.  
C - 일관성: 서로 다른 노드라도 같은 데이터를 받을 수 있어야 함.  
A - 가용성: 특정 노드에 장애가 생기더라도 서비스가 가능해야 함.  
P - 분리 내구성: 노드 간의 연결이 끊어지더라도 서비스가 가능해야 함.

가용성은 노드 자체가 멈추는 걸 의미하고, 분리 내구성은 노드들은 동작하는데 노드 간에 메세지를 주고받지 못하는 상황을 의미함.

#### 스키마란 무엇인가요?

데이터베이스의 전체적인 구조와 제약조건에 대한 명세

* 외부 스키마
  * 최종 사용자에게 필요한 데이터 명세
* 개념 스키마
  * 시스템 전체를 설계하기 위해 필요한 데이터베이스 논리적 구조
* 내부 스키마
  * 물리적 저장 장치에서 실제로 저장되는 구조

### 인덱스

#### 인덱스란 무엇인가요? 어떻게 동작 하나요?  

데이터베이스 인덱스는 데이터를 검색하는 속도를 높이기 위한 자료구조다. 인덱스를 유지하기 위해 추가적인 쓰기 작업 및 저장 공간이 필요하다. 특정 열들을 기반으로 O(n) 미만의 탐색 성능을 가진 자료구조를 생성해서 검색에 사용한다.

#### 인덱스의 알고리즘에는 어떤 것들이 있나요?  

작성 필요

#### Table Full Scan과 Index Range Scan 을 설명해주세요

작성 필요

### 트랜잭션

#### 트랜잭션이란 무엇인가요? 4가지 원칙을 포함해서 설명해 주세요

하나의 논리적 작업 단위를 구성하는 일련의 연산들의 집합. 따라서 연산 중 하나라도 실패하면 트랜잭션을 수행하기 전으로 되돌려놔야 함. 이와 관련된 원칙을 ACID라 부름.

* 원자성: 트랜잭션은 모든 연산이 정상적으로 수행되거나 어떤 연산도 수행하지 않는 두 가지 상태만 존재하는 걸 보장해야 함.
* 일관성: 성공적인 트랜잭션은 제약 조건에 맞지 않거나 프로그램 오류로 틀린 데이터를 데이터베이스에 반영하지 않음.
* 독립성: 동시에 수행되더라도 각각의 트랜잭션은 다른 트랜잭션에 영향을 받아선 안됨.
* 지속성: 트랜잭션이 성공적으로 완료되었다면, 그 결과는 향후에 발생한 소프트웨어/하드웨어 장애에 의해서 바뀌어선 안됨.

#### 트랜잭션의 격리 수준과 각 수준에서 발생할 수 있는 문제들에 대해 말해보세요

작성 필요

#### 공유 락과 배타 락의 차이는 무엇인가요?  

작성 필요

#### 데드락이란 무엇이며, 어떻게 발생할까요?  

작성 필요

## 알고리즘

### 전산 기본

빅오 표기법에 대해서 설명해주세요  
팩토리얼(factorial)을 구현해 보세요(손코딩).  
피보나치 수열 구현 방식 세 가지를 말해보시고, 시간복잡도와 공간복잡도를 설명해 주세요.  
BFS/DFS 차이는 무엇인가요?  
프림 알고리즘에 대해서 설명해 주세요.  
다익스트라 알고리즘에 대해서 설명해 주세요.  

### 정렬

정렬의 종류에는 어떤 것들이 있나요?  
삽입 정렬이 일어나는 과정을 설명해 보세요.  
퀵 정렬이 일어나는 과정을 설명해 보세요.  
54321 배열이 있을 때, 어떤 정렬을 사용하면 좋을까요?  
랜덤으로 배치된 배열이 있을때, 어떤 정렬을 사용하면 좋을까요?  
자릿수가 모두 같은 수가 담긴 배열이 있을 때, 어떤 정렬을 사용하면 좋을까요?  

## 자료구조

### 전산 기본

배열과 링크드 리스트의 차이점에 대해서 설명해 주세요.  
스택과 큐에 대해서 설명해 주세요.  
해시테이블에 대해서 설명해 주세요.  

### 트리

포화(Perfect) 이진트리, 완전(Complete) 이진트리, 정(Full) 이진트리의 차이점에 대해 각각 설명해주세요.  
그래프와 트리의 차이점에 대해서 설명해 주세요.  
힙 자료구조에 대해 설명해 주세요.  
힙의 삽입과 삭제는 어떻게 이루어지나요?  
레드 블랙 트리에 대해 설명해주세요.  
레드 블랙 트리의 삽입과 삭제 과정에 대해서 말해보세요.  
B-Tree에 대해서 설명해 주세요.  
최소 신장 트리에 대해서 설명해 주세요.  

## 프로그래밍

### 전산 기본

#### 재귀호출의 단점

함수 호출마다 시간과 스택 공간의 오버헤드 발생, 로직이 헷갈리기 때문에 문서화나 디버깅/유지보수 등이 어려움.  

객체지향이 무엇인가요? 절차지향과의 차이점은 뭐죠?  
객체지향 SOLID 원칙에 대해서 설명해 주세요.  
객체지향 4가지 특징에 대해서 설명해 주세요.  
대표적인 객체지향 언어에는 어떤 것들이 있나요?  
데이터 타입과 변수의 차이는 무엇인가요?  
함수형 프로그래밍에 대해서 설명해 주세요.  
AOP란 무엇인가요?  
컴파일러와 인터프리터의 차이는 무엇인가요?  
오버로딩과 오버라이딩의 차이는 무엇인가요?  
1급 객체에 대해서 설명해 주세요.  

### JAVA

#### 기본

Java 접근 제어자에 대해서 각각 설명해 주세요.  
JVM의 구조에 대해서 설명해 주세요.  
Garbage Collector 에 대해서 설명해 주세요. 어떻게 동작하나요?  
GC의 종류에 대해서 말해보세요.  
Java 버전 별 특성에 대해서 아는대로 말해주세요.  
Java는 Call By Value일까요, Call By Reference 일까요?  
리플렉션(Reflection)이란 무엇인가요?  
Stream API란 무엇인가요?  
Lambda란 무엇인가요?  
함수형 인터페이스란 무엇인가요?  
JVM 기동시 주로 사용되는 옵션들을 아는대로 말해보세요.  
foreach를 사용할 수 있는 자료구조는 어떤 인터페이스를 상속받고 있나요?  
iterator와 iterable 차이는 무엇인가요?  
synchronized 키워드에 대해 설명해 주세요.  
volatile 키워드에 대해 설명해 주세요.  
final 키워드에 대해서 설명해주세요. 각각의 쓰임에 따라 어떻게 동작하나요?  

#### 클래스와 객체

Wrapper Class란 무엇인가요?  
클래스, 객체, 인스턴스 차이에 대해서 설명해 주세요.  
직렬화(Serialization)과 역직렬화(Deserialization)에 대해서 설명해 주세요.  
Java Generic에 대해서 설명해 주세요.  
equals와 ==의 차이는 무엇인가요?  
hashCode란 무엇인가요?  
문자열을 리터럴(string = "abcd")로 할당하는 것과 객체(string = new String("abcd"))로 할당하는 방식의 차이가 무엇인가요?  
순수 추상 클래스와 인터페이스의 차이는 무엇인가요?  
본인 관점에서, 인터페이스는 주로 어떨 때 사용하나요?  

#### 자료형, 자료구조

Java의 Collection에 대해서 설명해 주세요.  
Array와 ArrayList의 차이점은 무엇인가요?  
char type과 string type으로 나뉘어져 있는 이유는 무엇인가요?  

## Design Pattern

### 디자인패턴

소프트웨어 설계 시 자주 일어나는 문제에 대한 일반적이고 재사용 가능한 해결법들

* 훌륭한 객체지향 디자인은 재사용성, 확장성, 관리의 용이성을 갖춘다
* 패턴은 훌륭한 객체지향 디자인 품질을 갖추고 있는 시스템을 만드는 방법을 제공함.
* 패턴은 검증받은 객체지향 경험의 산물이다.
* 패턴은 코드가 아닌 일반적인 해법이므로 어플리케이션에 적용하는 건 개발자의 몫
* 대부분의 패턴과 원칙은 소프트웨어 변경 문제와 관련 있음.
* 대부분의 패턴은 시스템의 일부분을 나머지 부분과 무관하게 변경하는 방법을 제공함.
* 많은 경우에 시스템에서 바뀌는 부분을 골라내서 캡슐화해야 함.
* 패턴은 다른 개발자들과의 의사소통의 가치를 극대화시킬 수 있는 전문 용어 역할을 함.

### 스트래티지 패턴

알고리즘군을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있도록 만든다. 스트래티지를 활용하면 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.

### 옵저버 패턴

한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다.

### 데코레이터 패턴

객체에 추가적인 요건을 동적으로 첨가한다. 데코레이터는 서브클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다.

### 팩토리 메소드 패턴

객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하게 만든다.

### 추상 팩토리 패턴

인터페이스를 이용하여 서로 연관되거나 의존하는 객체를 concrete 클래스를 지정하지 않고도 생성할 수 있다.

클라이언트가 사용하는 객체를 생성하는 부분만 변경이 일어난다면 팩토리로 분리해서 생성된 객체에 대해선 추상 인터페이스만 알아도 됨.

### 싱글톤 패턴

클래스의 인스턴스가 하나만 만들어지고, 어디서든지 그 인스턴스에 접근할 수 있도록 하기 위한 패턴

클래스의 생성자를 숨기고 클래스의 유일한 인스턴스만 반환하는 static 메서드 getInstance()를 정의한다. 즉, 객체가 하나만 생성되도록 직접 제어한다.

### 커맨드 패턴

요청 내역을 객체로 캡슐화하여 클라이언트를 서로 다른 요청 내역에 따라 매개변수화할 수 있다. 요청을 큐에 저장하거나 로그로 기록할 수도 있고 작업취소 기능을 지원할 수도 있다.

### 어댑터 패턴

호환되지 않는 클래스를 수정하지 않고 사용하기 위한 패턴

필요한 기능이 명시된 타겟 인터페이스를 상속한 Adapter class를 만들고 호환되지 않는 클래스를 composition 한다. 클라이언트는 이 Adapter class를 타겟 인터페이스로서 사용하고, Adapter class 내부에선 호환되지 않는 클래스에게 위임한다.

### 퍼사드 패턴

어떤 서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공한다. 퍼사드에서 고수준 인터페이스를 정의하기 때문에 서브시스템을 더 쉽게 사용할 수 있다.

### 템플릿 메소드 패턴

메소드에서 알고리즘의 골격을 정의한다. 알고리즘은 여러 단계로 나뉘고 그 중 일부는 서브클래스에서 구현할 수 있게 한다. 이를 통해 알고리즘의 구조는 그대로 유지하면서 서브클래스에서 특정 단계를 재정의할 수 있다.

### 이터레이터 패턴

컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있게 해 주는 방법을 제공해준다.

### 컴포지트 패턴

객체들을 트리 구조로 구성하여 부분과 전체를 나타내는 계층구조를 만들 수 있다. 이를 통해 클라이언트는 단독 객체거나 자식을 가지는 복합 객체라도 똑같은 방법으로 다룰 수 있다.

### 스테이트 패턴

여러가지 내부 상태들을 동일한 인터페이스 하에 캡슐화한다. 이를 통해 객체의 내부 상태가 바뀜에 따라서 객체의 행동을 바꿀 수 있다.

### 프록시 패턴

어떤 객체에 대한 접근을 제어하기 위한 용도로 대리인이나 대변인에 해당하는 객체를 제공하는 패턴

예시로 java의 RMI나 GRPC 같은 원격프로시저 콜이나 단위테스트를 예로 들 수 있다. stub을 통해 참조하고 있는 객체가 로컬에 있는지, 원격 접속인지, 아니면 테스트를 위한 더미 객체인지는 클라이언트는 신경 쓸 필요 없다.

### MVC 패턴

모델, 뷰, 컨트롤러로 나누는 패턴으로 비즈니스 로직과 UI가 자신의 변경에 대해 상대방에게 영향을 주지 않도록 할 수 있다. 여러 패턴의 조합의 대표적인 예로, 모델의 데이터 변경에 따라 뷰에서 업데이트가 일어날 때 옵저버 패턴이 쓰일 수 있고, 뷰를 구성하는 방법으로 HTML같이 트리 구조를 차용한다면 컴포지트 패턴으로 간주할 수 있다. 또한 같은 뷰라도 컨트롤러의 교체에 따라 다른 모델에 연결될 수 있다는 걸 생각해보면 스트래티지 패턴으로 볼 수 있다.

## ETC

### 전산 기본

TDD란 무엇인가요?  
프레임워크와 라이브러리 차이는 무엇인가요?  
디자인 패턴이란 무엇인가요?  
Monolitc Architecture, Micro Service Architecture에 대해 각각 설명해 주세요.  
애자일 방법론이란?  
도커란 무엇인가요?  

#### 보안의 3요소

기밀성: 인가받은 사용자만 정보 자산에 접근하는 걸 보장함.
무결성: 권한을 가진 사용자만이 정보를 변경할 수 있음을 보장함.
효율성: 정보에 대한 접근과 사용이 빨리 가능해야 함.

## 참조

### 질문 목록

* [기술면접 준비하기 - hygoogi](https://velog.io/@hygoogi/%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%AA%A8%EC%9D%8C)
* 프로그래밍 면접 이렇게 준비한다 - 존 몽건 외 2명, 한빛미디어

### 답변

* Wikipedia
* [해시넷](http://wiki.hash.kr/)
* [StudyTonight-OS tutorial](https://www.studytonight.com/operating-system/)
* [동기비동기블로킹논블로킹 IO - 배철오](https://www.slideshare.net/unitimes/sync-asyncblockingnonblockingio)
* Operating System Internals and Design Principles 8th edition - William Stallings, Pearson
* [TTA 정보통신용어사전](https://terms.tta.or.kr/)
* [정보통신기술용어해설](http://www.ktword.co.kr/)
* [MDN](https://developer.mozilla.org/)
* [생활코딩](https://www.opentutorials.org/)
* [W3Schools](https://www.w3schools.com/)
* [TCP School](http://tcpschool.com/)
* [레드햇](https://www.redhat.com/)
* [NHN Cloud meetup](https://meetup.toast.com/)
* [AWS](https://aws.amazon.com/)
* [Azure](https://azure.microsoft.com/)
* [한국데이터산업진흥원](https://kdata.or.kr/)
* [Wishket](https://www.wishket.com/)
